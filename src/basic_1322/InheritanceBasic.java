package basic_1322;
/**
 * 7장
 * 상속, 포함
 * 단일상속, Object
 * 오버라이드, super., super(), 제어자, 캡슐화
 * 접근제어자, 캡슐화, 생성자의 접근 제어자, 다형성(polymorphism)
 * @author SangJun
 *
 */
public class InheritanceBasic {
	/*
	 * 1. 상속(~은 ~이다)
	 * 		- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다
	 * 		- 적은 양의 코드로 새로운 클래스를 작성할 수 있다
	 * 		- 새로 작성하고자 하는 클래스의 뒤에 상속 받고자 하는 클래스의 이름을 키워드 'extends' 와 함께 써주기만 하면 된다
	 * 		class Child extends Parent{
	 * 			
	 * 		}
	 * 		
	 * 		- 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다
	 * 			: 조상클래스 - 부모클래스, 상위클래스, 기반클래스
	 * 			: 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
	 * 		- 멤버만 상속한다
	 * 		- 자손클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다
	 * 
	 * 2. 포함(~은 ~을 포함하고 있다)
	 * 		- 상속이외의 클래스를 재사용하는 방법
	 * 		- 한 클래스의 멤버변수로 다른클래스를 선언하는 방법이다
	 * 
	 * 3. 단일상속
	 * 		- 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
	 * 		class FireCar extends Car, Machine{// 상속 두개부터는 불가능
	 * 			
	 * 		}
	 * 		- Car와 Machine에 동일한 method가 있다면 어떤 것을 상속 받을지 알 수 없다
	 * 			Machine의 method명을 바꾼다면 그동안 사용되던 method를 사용하던 모든 메서드의 명을 수정해 주어야 한다
	 * 		- 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할수 있게 된다
	 * 
	 * 4. Object클래스(모든 클래스의 조상)
	 * 		- 모든 클래스의 상속계층도의 가장 위에 존재하는 조상클래스이다
	 * 		- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스를 상속받는다
	 * 		컴파일전
	 * 			class Tv{
	 * 				
	 * 			}
	 * 		컴파일후
	 * 			class Tv extends Object{
	 * 				Tv(){
	 * 				
	 * 				}
	 * 			}
	 * 
	 * 
	 * 5. 오버라이드(override)
	 * 		- 조상클래스로 부터 상속받은 메서드의 내용을 수정하는 것
	 * 		- 오버라이드가 되기위한 조건(선언부가 일치해야 한다.)
	 * 		: 자손클래스에서 오버라이드하는 메서드는 조상클래스의 이름이 같아야한다
	 * 			반환타입이 같아야 한다.
	 * 			매개변수의 타입과 개수가 같아야 한다
	 * 			리턴타입이 같아야 한다
	 * 		: 조상클래스의 메서드를 자손클래스에서 오버라이드 할때
	 * 			접근제어자를 조상클래스의 메서드보다 좁은 범위로 설정할 수 없다
	 * 			예외는 조상클래스의 메서드보다 많이 선언할 수 없다
	 * 			인스턴스메서드를 클래스메서드로 또는 그 반대로 변경할 수 없다
	 * 
	 * 6. super.
	 * 		- 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 서로 구별해야 하는 경우 사용
	 * 		- 조상멤버와 자신의 멤버를 구별할때 사용된다는 점을 제외하고는 this와 근본적으로 같다
	 * 		- 클래스메서드에서는 사용할 수 없고 인스턴스 메서드에만 사용 가능하다
	 * 
	 * 7. super() - 조상클래스의 생성자
	 * 		- this()와 마찬가지로 super() 역시 생성자 이다
	 * 		- this()는 같은 클래스의 다른 생성자를 호출할 때 사용
	 * 			super()는 조상클래스의 생성자를 호출할 때 사용
	 * 		- 생성자의 첫 줄에는 조상클래스의 생성자를 자동 호출한다
	 * 			자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있음으로 조상의 멤버들이 먼저 초기화 되어야 한다
	 * 
	 * 8. 제어자
	 * 		- 클래스, 변수, 메서드의 선언부에 사용된다
	 * 		- 접근제어자, 그외 제어자
	 * 		- 접근제어자 : public, protected, default, private
	 * 		- 그외제어자 : static, final, abstract, native,....
	 * 		- 접근제어자를 제일 왼쪽에 많이 둔다
	 * 		- static(클래스의, 공통적인)
	 * 			: 멤버변수, 메서드, 초기화 블럭에 사용된다
	 * 			: 클래스변수
	 * 				모든 인스턴스에서 공통적으로 사용한다
	 * 				인스턴스의 생성없이 사용할 수 있다
	 * 				클래스가 메모리에 로드될때 생성된다
	 * 			: 클래스메서드
	 * 				인스턴스의 생성없이 호출할 수 있다
	 * 				클래스메서드 내에서는 인스턴스멤버들을 사용할 수 없다
	 * 		
	 * 		- final(마지막의, 변경될 수 없는)
	 * 			: 변수에 사용시 ==> 값을 변경할 수 없는 상수가 된다
	 * 			: 메서드에 사용시 ==> 변경할 수 없는 메서드가 된다 ==> 오버라이드 할 수 없다
	 * 			: 클래스에 사용시 ==> 다른 클래스의 조상이 될 수 없다
	 * 		
	 * 		- abstract(추상의, 미완성의)
	 * 			: 메서드에 사용시 ==> 선언부만 작성하고 구현부는 작성되지 않은 추상메서드임을 나타낸다
	 * 			: 클래스에 사용시 ==> 추상메서드를 포함하고 있는 추상클래스가 된다
	 * 
	 * 9. 접근제어자
	 * 		- private : 같은 클래스
	 * 		- default : 같은 패키지
	 * 		- protected : 같은 패키지 + 다른 패키지의 자손클래스
	 * 		- public : 접근제한이 없다
	 * 		- 클래스에는 public과 default만 사용할 수 있다
	 * 		- 메서드와 멤버변수는 전부 사용가능하다
	 * 
	 * 10. 캡슐화
	 * 		- 접근제어자를 사용하는 이유
	 * 			: 외부로부터 데이터를 보호하기 위해
	 * 			: 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해
	 * 
	 * 11. 생성자의 접근 제어자
	 * 		- 인스턴스의 생성을 제한할 수 있다
	 * 		- 생성자의 접근 제어자를 private(보통 public)으로 지정
	 * 			: 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다
	 * 			: 다른 클래스의 조상이 될 수 없다
	 * 			: 해당 클래스는 상속할 수 없는 클래스임으로 final을 추가하여 상속할 수 없는 클래스 임을 알리는 것이 좋다
	 * 	
	 * 12. 다형성(polymorphism)
	 * 		- 여러가지 형태를 가질수 있는 능력
	 * 		- 한 타입의 참조변수로 여러타입의 인스턴스를 참조할 수 있다
	 * 		- 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다
	 * 			반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다
	 * 
	 * 
	 * 
	 */
}
