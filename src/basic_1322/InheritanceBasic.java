package basic_1322;
/**
 * 7장
 * 상속, 포함
 * 단일상속, Object
 * 오버라이드, super., super(), 제어자, 캡슐화
 * 접근제어자, 캡슐화, 생성자의 접근 제어자, 다형성(polymorphism)
 * instanceof연산자, 매개변수의 다형성, 여러가지 객체 배열 Vector, 추상클래스(abstract class), 인터페이스(interface)
 * @author SangJun
 *
 */
public class InheritanceBasic {
	/*
	 * 1. 상속(~은 ~이다)
	 * 		- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다
	 * 		- 적은 양의 코드로 새로운 클래스를 작성할 수 있다
	 * 		- 새로 작성하고자 하는 클래스의 뒤에 상속 받고자 하는 클래스의 이름을 키워드 'extends' 와 함께 써주기만 하면 된다
	 * 		class Child extends Parent{
	 * 			
	 * 		}
	 * 		
	 * 		- 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다
	 * 			: 조상클래스 - 부모클래스, 상위클래스, 기반클래스
	 * 			: 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
	 * 		- 멤버만 상속한다
	 * 		- 자손클래스의 멤버 개수는 조상클래스보다 항상 같거나 많다
	 * 
	 * 2. 포함(~은 ~을 포함하고 있다)
	 * 		- 상속이외의 클래스를 재사용하는 방법
	 * 		- 한 클래스의 멤버변수로 다른클래스를 선언하는 방법이다
	 * 
	 * 3. 단일상속
	 * 		- 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
	 * 		class FireCar extends Car, Machine{// 상속 두개부터는 불가능
	 * 			
	 * 		}
	 * 		- Car와 Machine에 동일한 method가 있다면 어떤 것을 상속 받을지 알 수 없다
	 * 			Machine의 method명을 바꾼다면 그동안 사용되던 method를 사용하던 모든 메서드의 명을 수정해 주어야 한다
	 * 		- 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할수 있게 된다
	 * 
	 * 4. Object클래스(모든 클래스의 조상)
	 * 		- 모든 클래스의 상속계층도의 가장 위에 존재하는 조상클래스이다
	 * 		- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스를 상속받는다
	 * 		컴파일전
	 * 			class Tv{
	 * 				
	 * 			}
	 * 		컴파일후
	 * 			class Tv extends Object{
	 * 				Tv(){
	 * 				
	 * 				}
	 * 			}
	 * 
	 * 
	 * 5. 오버라이드(override)
	 * 		- 조상클래스로 부터 상속받은 메서드의 내용을 수정하는 것
	 * 		- 오버라이드가 되기위한 조건(선언부가 일치해야 한다.)
	 * 		: 자손클래스에서 오버라이드하는 메서드는 조상클래스의 이름이 같아야한다
	 * 			반환타입이 같아야 한다.
	 * 			매개변수의 타입과 개수가 같아야 한다
	 * 			리턴타입이 같아야 한다
	 * 		: 조상클래스의 메서드를 자손클래스에서 오버라이드 할때
	 * 			접근제어자를 조상클래스의 메서드보다 좁은 범위로 설정할 수 없다
	 * 			예외는 조상클래스의 메서드보다 많이 선언할 수 없다
	 * 			인스턴스메서드를 클래스메서드로 또는 그 반대로 변경할 수 없다
	 * 
	 * 6. super.
	 * 		- 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 서로 구별해야 하는 경우 사용
	 * 		- 조상멤버와 자신의 멤버를 구별할때 사용된다는 점을 제외하고는 this와 근본적으로 같다
	 * 		- 클래스메서드에서는 사용할 수 없고 인스턴스 메서드에만 사용 가능하다
	 * 
	 * 7. super() - 조상클래스의 생성자
	 * 		- this()와 마찬가지로 super() 역시 생성자 이다
	 * 		- this()는 같은 클래스의 다른 생성자를 호출할 때 사용
	 * 			super()는 조상클래스의 생성자를 호출할 때 사용
	 * 		- 생성자의 첫 줄에는 조상클래스의 생성자를 자동 호출한다
	 * 			자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있음으로 조상의 멤버들이 먼저 초기화 되어야 한다
	 * 
	 * 8. 제어자
	 * 		- 클래스, 변수, 메서드의 선언부에 사용된다
	 * 		- 접근제어자, 그외 제어자
	 * 		- 접근제어자 : public, protected, default, private
	 * 		- 그외제어자 : static, final, abstract, native,....
	 * 		- 접근제어자를 제일 왼쪽에 많이 둔다
	 * 		- static(클래스의, 공통적인)
	 * 			: 멤버변수, 메서드, 초기화 블럭에 사용된다
	 * 			: 클래스변수
	 * 				모든 인스턴스에서 공통적으로 사용한다
	 * 				인스턴스의 생성없이 사용할 수 있다
	 * 				클래스가 메모리에 로드될때 생성된다
	 * 			: 클래스메서드
	 * 				인스턴스의 생성없이 호출할 수 있다
	 * 				클래스메서드 내에서는 인스턴스멤버들을 사용할 수 없다
	 * 		
	 * 		- final(마지막의, 변경될 수 없는)
	 * 			: 변수에 사용시 ==> 값을 변경할 수 없는 상수가 된다
	 * 			: 메서드에 사용시 ==> 변경할 수 없는 메서드가 된다 ==> 오버라이드 할 수 없다
	 * 			: 클래스에 사용시 ==> 다른 클래스의 조상이 될 수 없다
	 * 		
	 * 		- abstract(추상의, 미완성의)
	 * 			: 메서드에 사용시 ==> 선언부만 작성하고 구현부는 작성되지 않은 추상메서드임을 나타낸다
	 * 			: 클래스에 사용시 ==> 추상메서드를 포함하고 있는 추상클래스가 된다
	 * 
	 * 9. 접근제어자
	 * 		- private : 같은 클래스
	 * 		- default : 같은 패키지
	 * 		- protected : 같은 패키지 + 다른 패키지의 자손클래스
	 * 		- public : 접근제한이 없다
	 * 		- 클래스에는 public과 default만 사용할 수 있다
	 * 		- 메서드와 멤버변수는 전부 사용가능하다
	 * 
	 * 10. 캡슐화
	 * 		- 접근제어자를 사용하는 이유
	 * 			: 외부로부터 데이터를 보호하기 위해
	 * 			: 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해
	 * 
	 * 11. 생성자의 접근 제어자
	 * 		- 인스턴스의 생성을 제한할 수 있다
	 * 		- 생성자의 접근 제어자를 private(보통 public)으로 지정
	 * 			: 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다
	 * 			: 다른 클래스의 조상이 될 수 없다
	 * 			: 해당 클래스는 상속할 수 없는 클래스임으로 final을 추가하여 상속할 수 없는 클래스 임을 알리는 것이 좋다
	 * 	
	 * 12. 다형성(polymorphism)
	 * 		- 여러가지 형태를 가질수 있는 능력
	 * 		- 한 타입의 참조변수로 여러타입의 인스턴스를 참조할 수 있다
	 * 		- 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다
	 * 			반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다
	 * 
	 * 13. instanceof연산자
	 * 		- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
	 * 		- 연산결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다
	 * 		- 클래스메서드는 클래스 변수처럼 참조변수의 타입에 영향을 받는다
	 * 		- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다
	 * 
	 * 14. 매개변수의 다형성
	 * 		- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다
	 * 
	 * 15. 여러가지 객체 배열, Vector
	 * 		Product p1 = new Tv();
	 * 		Product p2 = new Computer();
	 * 		Product p3 = new NoteBook();
	 * 
	 * 		Product[] p = new Product[3];
	 * 		p[0] = p1;
	 * 		p[1] = p2;
	 * 		p[2] = p3;
	 * 
	 * 		- Vector
	 * 			: 배열을 사용할 경우 전체 크기를 한번 정하면 확장할 수 없다
	 * 				이를 Vector클래스를 이용하여 해결할 수 있다
	 * 			: 동적으로 크기가 관리되는 객체배열 이라고 생각하면 된다
	 * 			Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다
	 * 			add() : 객체를 추가한다
	 * 			remove() : 객체를 제거한다
	 * 			isEmpty() : Vector가 비어있는지 확인한다
	 * 			get(int index) : 지정된 위치에 있는 객체를 반환한다
	 * 			size() : 저장된 객체의 개수를 반환한다
	 * 
	 * 16. 추상클래스(abstract class)
	 * 		- 미완성된 클래스 : 미완성된 메서드를 포함하고 있다는 의미
	 * 		abstract class 클래스명{
	 * 		
	 * 		}
	 * 
	 * 		- 추상메서드
	 * 			: 메서드는 선언부와 구현부로 작성되어 있다
	 * 				선언부만 작성이 되고 구현부는 작성되지 않은 메서드를 추상메서드라고 한다
	 * 				abstract 반환타입 메서드명(매개변수~);
	 * 
	 * 17. 인터페이스(interface)
	 * 		- 일종의 추상클래스 이지만 추상메서드와 상수만 멤버로 가진다
	 * 		- 작성방법
	 * 			interface 인터페이스명{
	 * 				(public static final) 변수타입 변수명 = 값;// 상수이므로 대문자!
	 * 				(public abstract) 반환타입 메서드명(매개변수타입 변수명, ...);
	 * 			}
	 * 
	 * 		모든 멤버변수는 public static final 이어야 한다 (생략가능)
	 * 		모든 메서드는 public abstract 이어야 한다 (생략가능)
	 * 		
	 * 		- 인터페이스의 상속
	 * 			: 인터페이스는 인터페이스만 상속받을 수 있다
	 * 			(구현된 메서드를 상속받으면 더이상 인터페이스가 아니게 된다)
	 * 			: 클래스와 달리 다중상속이 가능하다
	 * 			: 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다
	 * 
	 * 		- 인터페이스의 구현
	 * 			: 자체로는 인스턴스를 생성할 수 없다
	 * 			: 자신의 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다
	 * 			: 클래스의 확장(extends), 인터페이스의 구현(implements)
	 * 			: 인터페이스의 일부 메서드만 구현했다면 그 클래스는 추상클래스로 선언 되어야 한다
	 * 			: 명칭 약속 : ~able(~을 할수 있는)
	 * 						I~
	 * 			
	 * 		- 인터페이스의 다형성
	 * 			: 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */
}
